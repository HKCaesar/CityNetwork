

;;;;
;; Synthetic generation of cities
;;;;






to generate-cities [generation-method]
  
  set-population-distribution
  
  if generation-method = "random" [
     foreach populations [
       create-cities 1 [set population ? setxy random-xcor random-ycor new-city] 
     ]
  ]
  
  
  if generation-method = "zipf-christaller" [
     foreach populations [
       let current-city nobody
       create-cities 1 [
         set population ? set current-city self new-city
       ]
       update-patches-weighted-pop
       let p next-christaller-patch
       ask current-city [move-to p]
     ]
  ]
  
  
  if generation-method = "prefAtt-diffusion-density" [
     ; external call to the density generator
     setup-synth-pattern
     set sp-max-pop sum populations set total-time-steps floor (sp-max-pop / sp-growth-rate)
     generate-synth-pattern
     
     ; than places 'abstract' nodes as cities depending on density distrib
     
     density-to-cities
     
  ]
  
end


;;
; Updates patch variables which are distance-weighted sum of population
;  (to be used for christaller patch selection)
to update-patches-weighted-pop
  ask patches [
    set distance-weighted-total-pop sum [distance myself / population] of cities
  ]
end

;;
;  Get randomly the next christaller patch
;  drawn according to proba prop to distance-weighted sum of pop
;   Q : filter on bord patches for example ?
to-report next-christaller-patch
  let tot sum [distance-weighted-total-pop] of patches let s 0 let r random-float 1 let found? false let res one-of patches
  ask patches [set s s + distance-weighted-total-pop / tot if s > r and not found? [set res self set found? true]]
  report res
end


;;
; get list of cities population
;  for now rank-size law
;  P_i : P_max / i^alpha
to set-population-distribution
  set populations []
  let i 1
  repeat #-cities [
    set populations lput (city-max-pop / (i ^ rank-size-exponent)) populations
    set i i + 1 
  ]
end


;;
; Transforms a spatialized density grid into an abstract (but also spatialized) city system
;
;  NOTE : must be a bijection density <-> cities, which form is fixed by given mechanisms
;      -- !! has a strong influence on nw generation as nw generation algorithms depend on city system organization.
to density-to-cities
  
  if density-to-cities-method = "random-aggreg" [
     
  ]
  
  if density-to-cities-method = "hierarchical-aggreg" [
     ; hierarchical aggreg == hierachical clustering on small initial entities located on each patch
     ;  stops when number of cities == #-cities
     ask patches [
       sprout-cities 1 [
          set population sp-occupants
          new-city
       ]
     ]
     
     init-cities-interaction-table
     
     cluster-cities
      
  ]
  
end

to cluster-cities
  table:remove cities-interaction-table "max-value" table:remove cities-interaction-table "max-key"
  ; cluster cities
     while [count cities > #-cities] [
       ; find max of interaction force
       let m 0 let m-key []
       foreach table:keys cities-interaction-table [let v table:get cities-interaction-table ? if v > m [set m v set m-key ?]]
       
       let k1 first m-key let k2 last m-key let c1 city k1 let c2 city k2
       let p1 [population] of c1 let p2 [population] of c2
       let t p1 / (p1 + p2)
       ; create the new city
       let nc nobody create-cities 1 [set nc self set population (p1 + p2) setxy (([xcor] of c1)* t + (1 - t) * ([xcor] of c2)) (([ycor] of c1)* t + (1 - t) * ([ycor] of c2) ) new-city]
       ask city k1 [die] ask city k2 [die]
       ; update pop table
       update-cities-interaction-table k1 k2 nc
     ]
end



to init-cities-interaction-table
  set cities-interaction-table table:make
  let city-list to-list cities
  let i 0 let m 0 let m-key []
  foreach but-last city-list [
    output-print (word "interaction-table : " i)
    let c1 ?
    ask c1 [
      let k1 who
      ask (other cities in-radius 20) [ ; approximation radius computed as : r~ 1/sqrt(espilon) * Pmax / Pmin * rmin
        let c2 self
        let k2 who let key (list k1 k2) let revkey (list k2 k1)
        if not (table:has-key? cities-interaction-table key or table:has-key? cities-interaction-table revkey) [
          let p12 cities-interaction-force c1 c2
          if p12 > m [set m p12 set m-key key]
          table:put cities-interaction-table key p12
        ]
      ]
    ]
    
;    let j i + 1 while [j < length city-list][
;      let c2 item j city-list let key (list [who] of c1 [who] of c2) ;let revkey (list [who] of c2 [who] of c1)
;      let p12 cities-interaction-force c1 c2 ; interaction force
;      if p12 > m [set m p12 set m-key key]
;      table:put cities-interaction-table key p12
;      ;table:put cities-interaction-table revkey p12 ; Q is revkey needed ? NO as couple matters
;      set j j + 1 
;    ]
    set i i + 1
  ]
  
  ; add special entries
  ;table:put cities-interaction-table "max-value" m
  ;table:put cities-interaction-table "max-key" m-key
  
  ;show table:keys cities-interaction-table
end


;;
; c1,c2 : ids of deletd cities
; newcity : newcity
to update-cities-interaction-table [n1 n2 newcity]
  let to-remove [] foreach table:keys cities-interaction-table [if member? n1 ? or member? n2 ? [set to-remove lput ? to-remove]]
  foreach to-remove [table:remove cities-interaction-table ?]
  
  ask newcity [
    let c1 self let k1 who let m 0 let m-key []
    ask (other cities in-radius 20) [ ; approximation radius computed as : r~ 1/sqrt(espilon) * Pmax / Pmin * rmin
      let c2 self
      let k2 who let key (list k1 k2) let revkey (list k2 k1)
      if not (table:has-key? cities-interaction-table key or table:has-key? cities-interaction-table revkey) [
        let p12 cities-interaction-force c1 c2
        if p12 > m [set m p12 set m-key key]
        table:put cities-interaction-table key p12
      ]
    ]
  ]
end


to-report cities-interaction-force [city1 city2]
  report runresult (word cities-interaction-method " city1 city2")
end


to-report basic-gravity [city1 city2]
  ; tunable gravity-exponent ?
  let d12 0 ask city1 [set d12 distance city2] ; not optimized, may be quicker to use potential vector and distance matrix
  report [population] of city1 * [population] of city2 / (d12 ^ basic-gravity-exponent)
end




to new-city
  set color green set shape "circle"
  set size max (list (3 * population / city-max-pop) 0.3)
end