
;;;;;;;;;;;;;;;
;; distances.nls
;;;;;;;;;;;;;;;



;;
;  Given euclidian and network distance matrices, computes effective distance matrix and corresponding effective paths
;
;  uses the fact that network distance matrix is sparse ? NO, uses heuristic to consider best network access as closest (not exact)
to update-effective-matrices
  
  verbose "Updating effective distances"
  
   ;; 
   ; d_eff = min(d_e,min_{l,l'}(d_e(i,l)+d_n(l,l')+d_e(l',j))
   ;
   ; if network is not pathologic, we can make the approximation d_e(i,l_min)+d_n(l_min,l'_min)+d_e(l'_min,j) - in the case of a connex network !
   ;  (counter examples exist)
   ;
   ; uses boolean matrix to get network patches ? or keep them in a variable ?
   
   
   ;let dmax sqrt ((world-width) ^ 2 + (world-height) ^ 2) ; already done before
   ;let n count patches
   ;let d-to-nw-patches matrix:times-element-wise (matrix:map [bool-to-int (?1 <= dmax)] network-distance-matrix) euclidian-distance-matrix
   
   let nw-patches-bool matrix:map [bool-to-int (?1 <= dmax)] network-distance-matrix
   
   ; not done here, but in network setup and/or update
   ;set nw-patches [] let i 0
   ;repeat n [if sum matrix:get-row nw-patches-bool i > 0 [set nw-patches lput i nw-patches] set i i + 1]
   
   set effective-shortest-paths table:make
   
   ifelse nw-patches != [] [
     ;optimization : contruct a table giving index of nearest nw patch
     let nw-access-table table:make let i 0
     repeat #-patches [table:put nw-access-table i (min-index (matrix-get-sparse-row euclidian-distance-matrix i nw-patches)) set i i + 1]
   
     ;; fill effective distance matrix
     let p1 0 let p2 0
     repeat #-patches [
       set p2 0
       repeat #-patches [
          let a1 table:get nw-access-table p1 let a2 table:get nw-access-table p2
          ; connectivity of nw is taken into account : if a1->a2 does not exists in nw, will be initialized at dmax+ (\infty) and minimum will be euclidian distance
          matrix:set effective-distance-matrix p1 p2 min list (matrix:get euclidian-distance-matrix p1 p2) ((matrix:get euclidian-distance-matrix p1 a1) + (matrix:get euclidian-distance-matrix p2 a2) + (matrix:get network-distance-matrix a1 a2))
          
          ;;;;
          ;; Pb : here need to check for each connected cluster ?
          ;;
          ;;
          
          ;; TODO :: add lambda and nu parameters, take network speed into account (for now, network not used ?) -> done in update-nw-matrix
          
          set p2 p2 + 1
       ]
       set p1 p1 + 1
     ]
   
   ][
     ; if empty, just copy euclidian distance matrix
     set effective-distance-matrix matrix:copy euclidian-distance-matrix
   ]
   
end




;;
; update network matrices if a new link is added
; @param new-link new link (entirely)
;
; Dynamic programming paradigm
to update-network [new-link]
  
  verbose "Updating network paths and distances"
  
  ;;;;;;;;;;;;;;;
  ;; I) Update Network intersections
  ;;;;;;;;;;;;;;;
  
  let r get-new-inters new-link
  let new-inters first r
  let in-between item 1 r
  let new-nw-patches last r
  
  update-inters new-inters in-between

  ;;;;;;;;;;;;;;;
  ;; II) Update shortest paths between intersections
  ;;;;;;;;;;;;;;;
  
  ; update paths table with new possible paths
  update-vertices-and-paths new-inters
  
  ; update distances accordingly
  update-network-distance-matrix
  
  ; check if possible shorcuts through the newly created link
  update-shortest-paths new-inters

  
  ;;;;;;;;;;;;;;;
  ;; III) Update network distances
  ;;;;;;;;;;;;;;;
  
  update-network-distance-matrix
  
  
  ;;;;;;;;;;;;;;;
  ;; IV) Update NW Patches
  ;;;;;;;;;;;;;;;
 
  update-nw-patches new-nw-patches
  
end





;;
; given a new link, reports 
;  [patches of intersections , in-between patches , new network patches ]
to-report get-new-inters [new-link]
  
  debug (word "getting new inters for link " new-link)
  
  ; get footprint of the link, all patches of it are connected
  let new-nw-patches [] ask new-link [foreach footprint[ask ? [set new-nw-patches lput number new-nw-patches]]]
  
  ; find intersections : as footprint is ordered, new intersections are orderered too.
  let new-inters (list (first new-nw-patches))
  let is-in-nw-matrix? matrix:map [bool-to-int (?1 != -1)] network-distance-matrix
  let in-between (list (list first new-nw-patches)) ; patches between consecutive intersections
  foreach but-first but-last new-nw-patches [   
    set in-between lput (lput ? (last in-between)) (but-last in-between)
    if sum matrix:get-row is-in-nw-matrix? ? > 0 [
      set new-inters lput ? new-inters set in-between lput (list ?) in-between
    ]
  ]
  
  ; Q : link extremities not needed ?
  set new-inters lput (last new-nw-patches) new-inters
  set in-between lput (lput (last new-nw-patches) (last in-between)) (but-last in-between)
  
  
  report (list new-inters in-between new-nw-patches)
  
end




;;
; 
to update-inters [new-inters in-between]
  
  debug (word "updating intersections with inters " new-inters )
  
  
  ;;corresponding 'nw-closest-inter' entries
  let i 0
  foreach in-between [
    foreach ? [
       let closest-inters []
       if i >= 0 [set closest-inters lput (list (item i new-inters) (matrix:get euclidian-distance-matrix ? (item i new-inters))) closest-inters]
       if (i + 1) < (length new-inters) [set closest-inters lput (list (item (i + 1) new-inters) (matrix:get euclidian-distance-matrix ? (item (i + 1) new-inters))) closest-inters]
       table:put closest-nw-inters ? closest-inters
    ]
    set i i + 1
  ]
  
  
  
  ;; add intersections
  foreach new-inters [
    
    set nw-inters lput ? nw-inters
    
    ;; update nw-closest-inter for crossing link
    let ni ?
    
    if table:has-key? closest-nw-inters ? [
       let prev-crossing-ends table:get closest-nw-inters ?
       table:remove closest-nw-inters ?
       foreach table:keys closest-nw-inters [
         let chge? (length prev-crossing-ends = length table:get closest-nw-inters ?)
         if chge? [
           let i 0 foreach table:get closest-nw-inters ? [set chge? (chge? and first ? = first item i prev-crossing-ends) set i i + 1]
           set i 0 let chgerev true foreach rev table:get closest-nw-inters ? [set chgerev (chgerev and first ? = first item i prev-crossing-ends) set i i + 1]
           set chge? (chge? or chgerev)
         ]
        ; output-print chge?
         if chge? [
           let oldints table:get closest-nw-inters ? let nints []
           ;output-print length oldints
;           ifelse length oldints = 1 [
;             let dni matrix:get euclidian-distance-matrix ? ni let d1 matrix:get euclidian-distance-matrix ? first first oldints
;             ifelse d1 < dni [set nints (list (list ni dni) (list (first first oldints) d1))][set nints (list (list ni dni))]
;           ][
           
             let dni matrix:get euclidian-distance-matrix ? ni let d1 matrix:get euclidian-distance-matrix ? first first oldints let d2 matrix:get euclidian-distance-matrix ? first last oldints
             let dn1 matrix:get euclidian-distance-matrix ni first first oldints
             ; output-print (word "dni : " dni " - d1 : " d1 " - d2 : " d2 " - dn1 : " dn1)  ; DEBUG
             ifelse d1 + dni = dn1 [set nints (list (list ni dni) (list (first first oldints) d1))][set nints (list (list ni dni) (list (first last oldints) d2))]
           ;]
           table:put closest-nw-inters ? nints
         ]
       ]
    ]
  ]
  
  
  
  
  
  
end






;; add new vertices and corresponding paths
;
to update-vertices-and-paths [new-inters]
  
  debug (word "updating vertices for inters " new-inters)
  
  foreach new-inters [
    let o ?
    
    ;; connect to all vertices
    ; includes self to self paths and direct paths between new vertices
    foreach nw-inters [
      let d ?
      
      debug (word "adding " o " -> " d)
      
      ifelse member? ? new-inters [
         ; if also new inter, add direct path 
         ifelse position o new-inters < position d new-inters [
           table:put network-shortest-paths (list o d) (sublist new-inters (position o new-inters) ((position d new-inters) + 1))
         ][
           table:put network-shortest-paths (list o d) (rev sublist new-inters (position d new-inters) ((position o new-inters) + 1))
         ]
         
         debug (word "... directly : " table:get network-shortest-paths (list o d))
         
      ][
         ; else find closest neighbor -> closest inters shall give neighbors for a vertice
         ; put path in both senses here because directed path
         
         let path [] let dmin -1
         foreach table:get closest-nw-inters o [
            if table:has-key? network-shortest-paths (list d (first ?)) and dmin > 0 [
              let dpot (matrix:get network-distance-matrix d (first ?) + (last ?))
              if dpot < dmin [
                 set dmin dpot set path (lput o table:get network-shortest-paths (list d (first ?)))
              ]
            ]
         ]
         
         table:put network-shortest-paths (list d o) path table:put network-shortest-paths (list o d) rev path
         
         debug (word "... via neighbors : " table:get network-shortest-paths (list o d))
         
      ]
    ]
    
    ;
    ;; foreach path, add intermediate step if the intersection is on an old edge
    ;
    let changed-paths table:make
    foreach table:keys network-shortest-paths [
      let ind ? let p table:get network-shortest-paths ?
      ; iterate on couples of neighbors
      let neighs table:get closest-nw-inters o
      let i 0 let j 1 repeat length neighs - 1 [set j (i + 1) repeat (length neighs) - i - 1 [
          let n1 item i neighs let n2 item j neighs
          
          ; add the new vertex if between two existing vertices of a path
          if member? n1 p and member? n2 p [
            ifelse position n1 p < position n2 p [
               table:put changed-paths ind (concatenate (list (sublist p 0 (position n1 p + 1)) (list o) (sublist p (position n2 p) length p)) )
            ][
               table:put changed-paths ind (concatenate (list (sublist p 0 (position n2 p + 1)) (list o) (sublist p (position n1 p) length p)) )
            ]
          ]
          
          set j j + 1] set i (i + 1)]
    ]
    foreach table:keys changed-paths [table:put network-shortest-paths ? (table:get ? changed-paths)]    
  ]
  
  
  
end


;; check for possible new shorcuts through the newly created link
to update-shortest-paths [new-inters]
  
  debug "computing shortcuts" ; DEBUG
  
  ; iterate on each couple of intersection, as each couple can be a shortcut
  let i 0 let j 1
  repeat length new-inters - 1 [
    set j i + 1
    repeat length new-inters - i - 1 [
      debug (word "shorcut " (item i new-inters) " -> " (item j new-inters))
      shortcut (item i new-inters) (item j new-inters)
      set j j + 1 
    ]
    set i i + 1 
  ]
  
end



;;
; shorcuts existing paths if possible for the given intersection
;
to shortcut [i1 i2]
  
  let new-paths table:make
  
  ; test all existing paths
  foreach table:keys network-shortest-paths [
    let ind ? let p table:get network-shortest-paths ?
    let o first ? let d last ?
    
    ; used iff none is -1
    let dpot (matrix:get network-distance-matrix o i1 + matrix:get network-distance-matrix i2 d + matrix:get euclidian-distance-matrix i1 i2)
    ifelse p = [] [
      if table:get network-shortest-paths (list o i1) != [] and table:get network-shortest-paths (list i2 d) != [] [
         ; here connect two old weak component clusters
         table:put network-shortest-paths ind (concatenate (list table:get network-shortest-paths (list o i1) table:get network-shortest-paths (list i2 d) ))   
         matrix:set network-distance-matrix o d dpot  
      ]
    ][
      if member? i1 p and member? i2 p [
          ; update only if new distance is strictly shortest
          
          if matrix:get network-distance-matrix o d > dpot [
            ifelse position i1 p < position i2 p [
              table:put new-paths ind (concatenate (list (sublist p 0 (position i1 p + 1)) (sublist p (position i2 p) length p)) )
                ][
              table:put new-paths ind (concatenate (list (sublist p 0 (position i2 p + 1)) (sublist p (position i1 p) length p)) )
            ]
            matrix:set network-distance-matrix o d dpot  
          ]
      ]
    ]
  ]
  
  ;; update paths in table
  foreach table:keys new-paths [table:put network-shortest-paths ? (table:get new-paths ?)]
  
  
  ;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; old proc through neighbors
  
;  output-print (word "updating " length table:keys network-shortest-paths " paths...")
;  let new-shortest-paths table:make
;  foreach table:keys network-shortest-paths [
;    let o first ? let d last ?
;    let dmin matrix:get network-distance-matrix o d let pmin table:get network-shortest-paths ? let dpot 0
;    ; 1-1
;    if (table:has-key? network-shortest-paths (list o (first first (table:get closest-nw-inters i1)))) and (table:has-key? network-shortest-paths (list (first first (table:get closest-nw-inters i2)) d))[
;      set dpot ((matrix:get network-distance-matrix o (first first (table:get closest-nw-inters i1))) + last first (table:get closest-nw-inters i1) + matrix:get euclidian-distance-matrix i1 i2 + last first (table:get closest-nw-inters i2) + (matrix:get network-distance-matrix d (first first (table:get closest-nw-inters i2))))
;      if dpot < dmin [set dmin dpot set pmin concatenate (list (table:get network-shortest-paths (list o (first first (table:get closest-nw-inters i1)))) (list i1 i2) (table:get network-shortest-paths (list (first first (table:get closest-nw-inters i2)) d)))]
;    ]
;    ; 2-1
;    if (table:has-key? network-shortest-paths (list o (first last (table:get closest-nw-inters i1)))) and (table:has-key? network-shortest-paths (list (first first (table:get closest-nw-inters i2)) d))[
;      set dpot ((matrix:get network-distance-matrix o (first last (table:get closest-nw-inters i1))) + last last (table:get closest-nw-inters i1) + matrix:get euclidian-distance-matrix i1 i2 + last first (table:get closest-nw-inters i2) + (matrix:get network-distance-matrix d (first first (table:get closest-nw-inters i2))))
;      if dpot < dmin [set dmin dpot set pmin concatenate (list (table:get network-shortest-paths (list o (first last (table:get closest-nw-inters i1)))) (list i1 i2) (table:get network-shortest-paths (list (first first (table:get closest-nw-inters i2)) d)))]
;    ]
;    ; 1-2
;    if (table:has-key? network-shortest-paths (list o (first first (table:get closest-nw-inters i1)))) and (table:has-key? network-shortest-paths (list (first last (table:get closest-nw-inters i2)) d))[
;      set dpot ((matrix:get network-distance-matrix o (first first (table:get closest-nw-inters i1))) + last first (table:get closest-nw-inters i1) + matrix:get euclidian-distance-matrix i1 i2 + last last (table:get closest-nw-inters i2) + (matrix:get network-distance-matrix d (first last (table:get closest-nw-inters i2))))
;      if dpot < dmin [set dmin dpot set pmin concatenate (list (table:get network-shortest-paths (list o (first first (table:get closest-nw-inters i1)))) (list i1 i2) (table:get network-shortest-paths (list (first last (table:get closest-nw-inters i2)) d)))]
;    ]
;    ; 2-2
;    if (table:has-key? network-shortest-paths (list o (first last (table:get closest-nw-inters i1)))) and (table:has-key? network-shortest-paths (list (first last (table:get closest-nw-inters i2)) d))[   
;      set dpot ((matrix:get network-distance-matrix o (first last (table:get closest-nw-inters i1))) + last last (table:get closest-nw-inters i1) + matrix:get euclidian-distance-matrix i1 i2 + last last (table:get closest-nw-inters i2) + (matrix:get network-distance-matrix d (first last (table:get closest-nw-inters i2))))
;      if dpot < dmin [set dmin dpot set pmin concatenate (list (table:get network-shortest-paths (list o (first last (table:get closest-nw-inters i1)))) (list i1 i2) (table:get network-shortest-paths (list (first last (table:get closest-nw-inters i2)) d)))]
;    ]
;    
;    table:put new-shortest-paths (list o d) pmin
;    
;  ]
;  
;  ;foreach table:keys new-paths [table:put new-shortest-paths]
;  
;  report new-shortest-paths

end



;;
; Update nw patches variables
to update-nw-patches [new-nw-patches]
   foreach new-nw-patches [
    set nw-patches lput ? nw-patches 
  ]
  
  ; diagonal of distance matrix
  foreach nw-patches [
      matrix:set network-distance-matrix ? ? 0
  ]
end




;; 
; update nw distance matrix
; assuming shortest paths have been computed
;
to update-network-distance-matrix
  set network-distance-matrix matrix:make-constant #-patches #-patches -1
  foreach table:keys network-shortest-paths [ 
    matrix:set network-distance-matrix (first ?) (last ?) (congested-distance table:get network-shortest-paths ?)
  ]
end



;;
; given a path, reports generalized time to go through it
to-report congested-distance [path]
  let res 0
  if length path > 0 [
    let current-patch first path
    foreach but-first path [
      let next-patch ?
      set res res + (matrix:get euclidian-distance-matrix current-patch next-patch) * network-min-pace * (item current-patch patches-congestion + item next-patch patches-congestion) / 2
      set current-patch next-patch 
    ]
  ]
  report res
end







  

