
;;;;;;;;;;;;;;;
;; distances.nls
;;;;;;;;;;;;;;;



;;
;  Given euclidian and network distance matrices, computes effective distance matrix and corresponding effective paths
;
;  uses the fact that network distance matrix is sparse ? NO, uses heuristic to consider best network access as closest (not exact)
to update-effective-matrices
   ;; 
   ; d_eff = min(d_e,min_{l,l'}(d_e(i,l)+d_n(l,l')+d_e(l',j))
   ;
   ; if network is not pathologic, we can make the approximation d_e(i,l_min)+d_n(l_min,l'_min)+d_e(l'_min,j) - in the case of a connex network !
   ;  (counter examples exist)
   ;
   ; uses boolean matrix to get network patches ? or keep them in a variable ?
   
   
   ;let dmax sqrt ((world-width) ^ 2 + (world-height) ^ 2) ; already done before
   let n count patches
   ;let d-to-nw-patches matrix:times-element-wise (matrix:map [bool-to-int (?1 <= dmax)] network-distance-matrix) euclidian-distance-matrix
   
   let nw-patches-bool matrix:map [bool-to-int (?1 <= dmax)] network-distance-matrix
   let nw-patches [] let i 0
   repeat n [if sum matrix:get-row nw-patches-bool i > 0 [set nw-patches lput i nw-patches] set i i + 1]
   
   set effective-shortest-paths table:make
   
   ifelse nw-patches != [] [
     ;optimization : contruct a table giving index of nearest nw patch
     let nw-access-table table:make set i 0
     repeat n [table:put nw-access-table i (min-index (matrix-get-sparse-row euclidian-distance-matrix i nw-patches)) set i i + 1]
   
     ;; fill effective distance matrix
     let p1 0 let p2 0
     repeat n [
       set p2 0
       repeat n [
          let a1 table:get nw-access-table p1 let a2 table:get nw-access-table p2
          ; connectivity of nw is taken into account : if a1->a2 does not exists in nw, will be initialized at dmax+ (\infty) and minimum will be euclidian distance
          matrix:set effective-distance-matrix p1 p2 min list (matrix:get euclidian-distance-matrix p1 p2) ((matrix:get euclidian-distance-matrix p1 a1) + (matrix:get euclidian-distance-matrix p2 a2) + (matrix:get network-distance-matrix a1 a2))
          
          ;;;;
          ;; Pb : here need to check for each connected cluster ?
          ;;
          ;;
          
          ;; TODO :: add lambda and nu parameters, take network speed into account (for now, network not used ?) -> done in update-nw-matrix
          
          set p2 p2 + 1
       ]
       set p1 p1 + 1
     ]
   
   ][
     ; if empty, just copy euclidian distance matrix
     set effective-distance-matrix matrix:copy euclidian-distance-matrix
   ]
   
end



;;
; update network matrices if a new link is added
; @param new-link new link (entirely)
;
; Dynamic programming paradigm
to update-network-matrices [new-link]
  
  ; get footprint of the link, all patches of it are connected
  let new-nw-patches [] ask new-link [ask footprint[set new-nw-patches lput [number] of myself new-nw-patches]]
  
  ; find intersections : pb better be consecutive...
  let new-inters [] let is-in-nw-matrix? matrix:map [bool-to-int (?1 <= dmax)] network-distance-matrix
  foreach new-nw-patches [
    if sum matrix:get-row is-in-nw-matrix? ? > 0 [set new-inters lput ? new-inters]
  ]
  
end