
;;;;;;;;;;;;;;;
;; distances.nls
;;;;;;;;;;;;;;;



;;
;  Given euclidian and network distance matrices, computes effective distance matrix and corresponding effective paths
;
;  uses the fact that network distance matrix is sparse ? NO, uses heuristic to consider best network access as closest (not exact)
to update-effective-matrices
   ;; 
   ; d_eff = min(d_e,min_{l,l'}(d_e(i,l)+d_n(l,l')+d_e(l',j))
   ;
   ; if network is not pathologic, we can make the approximation d_e(i,l_min)+d_n(l_min,l'_min)+d_e(l'_min,j) - in the case of a connex network !
   ;  (counter examples exist)
   ;
   ; uses boolean matrix to get network patches ? or keep them in a variable ?
   
   
   ;let dmax sqrt ((world-width) ^ 2 + (world-height) ^ 2) ; already done before
   let n count patches
   ;let d-to-nw-patches matrix:times-element-wise (matrix:map [bool-to-int (?1 <= dmax)] network-distance-matrix) euclidian-distance-matrix
   
   let nw-patches-bool matrix:map [bool-to-int (?1 <= dmax)] network-distance-matrix
   
   ; not done here, but in network setup and/or update
   ;set nw-patches [] let i 0
   ;repeat n [if sum matrix:get-row nw-patches-bool i > 0 [set nw-patches lput i nw-patches] set i i + 1]
   
   set effective-shortest-paths table:make
   
   ifelse nw-patches != [] [
     ;optimization : contruct a table giving index of nearest nw patch
     let nw-access-table table:make let i 0
     repeat n [table:put nw-access-table i (min-index (matrix-get-sparse-row euclidian-distance-matrix i nw-patches)) set i i + 1]
   
     ;; fill effective distance matrix
     let p1 0 let p2 0
     repeat n [
       set p2 0
       repeat n [
          let a1 table:get nw-access-table p1 let a2 table:get nw-access-table p2
          ; connectivity of nw is taken into account : if a1->a2 does not exists in nw, will be initialized at dmax+ (\infty) and minimum will be euclidian distance
          matrix:set effective-distance-matrix p1 p2 min list (matrix:get euclidian-distance-matrix p1 p2) ((matrix:get euclidian-distance-matrix p1 a1) + (matrix:get euclidian-distance-matrix p2 a2) + (matrix:get network-distance-matrix a1 a2))
          
          ;;;;
          ;; Pb : here need to check for each connected cluster ?
          ;;
          ;;
          
          ;; TODO :: add lambda and nu parameters, take network speed into account (for now, network not used ?) -> done in update-nw-matrix
          
          set p2 p2 + 1
       ]
       set p1 p1 + 1
     ]
   
   ][
     ; if empty, just copy euclidian distance matrix
     set effective-distance-matrix matrix:copy euclidian-distance-matrix
   ]
   
end



;;
; update network matrices if a new link is added
; @param new-link new link (entirely)
;
; Dynamic programming paradigm
to update-network-matrices [new-link]
  
  ;;;;;;;;;;;;;;;
  ;; I) Shortest paths update
  ;;;;;;;;;;;;;;;
  
  ; get footprint of the link, all patches of it are connected
  let new-nw-patches [] ask new-link [foreach footprint[ask ? [set new-nw-patches lput number new-nw-patches]]]
  
  ; find intersections : as footprint is ordered, new intersections are orderered too.
  let new-inters (list (first new-nw-patches)) let is-in-nw-matrix? matrix:map [bool-to-int (?1 <= dmax)] network-distance-matrix
  let in-between [[]] ; patches between consecutive intersections
  foreach but-first but-last new-nw-patches [
    set in-between lput (lput ? (last in-between)) (but-last in-between)
    if sum matrix:get-row is-in-nw-matrix? ? > 0 [set new-inters lput ? new-inters set in-between lput [] in-between]
  ]
  set new-inters lput (last new-nw-patches) new-inters
  set in-between lput (lput (last new-nw-patches) (last in-between)) (but-last in-between)
  
  
  ; for each couple of consecutive intersections, update path table with following updates :
  ;   - add shortcuts if needed for each already existing path
  ;   - for each previous nw patch, connect it to each new patch (do not forget reciprocity)
  ;   - connect new patches between themselves (idem)
  
  ; table for new and modified entries
  let new-entries-nw-table table:make
  
  ; interate on consecutive inters - note : at least both ends even if does not intersects.
  let i 0
  repeat ((length new-inters) - 1) [
    let i1 item i new-inters let i2 item (i + 1) new-inters
    let ib item i in-between
    
    ; add shortcuts iff i1 and i2 are already in network
    if sum matrix:get-row is-in-nw-matrix? i1 > 0 and sum matrix:get-row is-in-nw-matrix? i2 > 0 [ ; may be a shortcut
       foreach table:keys network-shortest-paths [
          table:put new-entries-nw-table ? (shortcut ? (list i1 i2))
       ]
    ]
    
    ; connect new patches with old ones
    ; use new paths ? not needed as the path to a in-between patch cannot go through both i1 and i2
    let ib-p 0 ; index of in-betweeen patch
    foreach ib [
      let d ?
      foreach nw-patches [
        let o ?
        let d1 matrix:get network-distance-matrix o i1 let d2 matrix:get network-distance-matrix o i2 let p []
        ifelse d1 < d2 [
          set p concatenate list (table:get network-shortest-paths (list o i1)) (sublist ib 0 (ib-p + 1))
        ][
          set p rev (concatenate list (sublist ib ib-p (length ib)) (table:get network-shortest-paths (list i2 o)))
        ]
        table:put new-entries-nw-table (list o d) p
        table:put new-entries-nw-table (list d o) (rev p)
      ]
      set ib-p ib-p + 1
    ]
    
    set i i + 1
  ]
  
  ; connect new patches between themselves
  let i-o 0
  foreach new-nw-patches [
    let i-d 0 let o ?
    foreach new-nw-patches [
      let d ?
      table:put new-entries-nw-table (list o d) (sublist new-nw-patches (min list i-o i-d) ((max list i-o i-d) + 1) )
      set i-d i-d + 1
    ] 
    set i-o i-o + 1
  ]
  
  ; update the shortest path table
  set network-shortest-paths new-entries-nw-table
  
  
  ;;;;;;;;;;;;;;;
  ;; II) Distance update
  ;;;;;;;;;;;;;;;
  
  ; map sum of distances to table ?
  ; ¡¡ do not forget to use congestion and network speed here !!
  let n count patches
  
  set network-distance-matrix matrix:make-constant n n (dmax + 1)
  foreach table:keys network-shortest-paths [ 
    matrix:set network-distance-matrix (first ?) (last ?) (congested-distance table:get network-shortest-paths ?)
  ]
  
  
  ;;;;;;;;;;;;;;;
  ;; III) NW patches update
  ;;;;;;;;;;;;;;;
  let nw-patches-bool matrix:map [bool-to-int (?1 <= dmax)] network-distance-matrix
  set nw-patches [] set i 0
  repeat n [if sum matrix:get-row nw-patches-bool i > 0 [set nw-patches lput i nw-patches] set i i + 1]

  
end


;;
; shorcuts path if possible
;
;  no loops in paths -> position-of-element will be unique if exists
to-report shortcut [path cut]
   let p1 position (first cut) path let p2 position (last cut) path
   ifelse p1 != false and p2 != false [
     let res [] let i 0
     repeat (min list p1 p2) + 1 [
       set res lput (item i path) res set i i + 1
     ] set i (max list p1 p2 )
     repeat (length path - max list p1 p2) [set res lput (item i path) res set i i + 1]
     report res
   ][
     report path
   ]
end


;;
; given a path, reports generalized time to go through it
to-report congested-distance [path]
  let res 0
  let current-patch first path
  foreach but-first path [
    let next-patch ?
    set res res + (matrix:get euclidian-distance-matrix current-patch next-patch) * network-min-pace * (item current-patch patches-congestion + item next-patch patches-congestion) / 2
    set current-patch next-patch 
  ]
  report res
end







  

