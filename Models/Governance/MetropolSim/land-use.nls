
;;;;;;;;;;;;;;;;;
;; land-use
;;;;;;;;;;;;;;;;;


;; land-use evolution
to land-use
  
  repeat 10 [
    repeat 10 [
      updateUtilites
      mouvementsActifs
      displayActifs
    ]
  
    repeat 10 [
      updateUtilites
      mouvementsEmplois
      displayEmplois
    ]
  ]


end




to updateUtilites
  updateDensityActifs
  updateDensityEmplois
  updateutiliteActifs
  updateutiliteEmplois
end




to updateDensityActifs
let tempActifs 0
ask patches [
let c 0
set listDensiteActifs []
while [c < Ncsp] [
  let j 0
  set tempActifs 0
   while [j < length listPatchesRegion] [
    let m 0
    while [m < nModes] [
      let tempShare item j item c item m listModesShare
      let tempCout coutDistance (item j item c item m listCoutTransport)
      ;set tempActifs tempActifs + tempShare * (item c [listAnbrR] of item j listPatchesRegion + item c [listAnbrM] of item j listPatchesRegion) * tempCout
       ifelse item j listPatchesRegion = self
       [
        set tempActifs tempActifs +  (item c listAnbrR + item c listAnbrM)
       ]
       [
       set tempActifs tempActifs + (item c [listAnbrR] of item j listPatchesRegion + item c [listAnbrM] of item j listPatchesRegion) / distance item j listPatchesRegion 
       ]
       set m m + 1
    ]
    set j j + 1
  ]
  set listDensiteActifs lput tempActifs listDensiteActifs
  set c c + 1
]

]

end





to updateDensityEmplois

let tempEmplois 0
ask patches [
let c 0
set listDensiteEmplois []

while [c < Ncsp] [
  let j 0
   set tempEmplois 0
  while [j < length listPatchesRegion] [
    let m 0
    while [m < nModes] [
      let tempShare item j item c item m listModesShare
      let tempCout coutDistance(item j item c item m listCoutTransport)
      ;set tempEmplois tempEmplois + tempShare * (item c [listEnbr] of item j listPatchesRegion) * tempCout
             ifelse item j listPatchesRegion = self
       [
        set tempEmplois tempEmplois +  (item c listEnbr)
       ]
       [
       set tempEmplois tempEmplois + (item c [listEnbr] of item j listPatchesRegion) / distance item j listPatchesRegion 
       ]
      
      
      set m m + 1
    ]
    set j j + 1
  ]
  set listDensiteEmplois lput tempEmplois listDensiteEmplois
  set c c + 1
]

]

end







to updateUtiliteActifs
let tempL []
let c 0
while  [c < Ncsp] [
  set tempL lput 0 tempL
  set c c + 1
]


ask patches [
set c 0
while [c < Ncsp] [
  set listAutiliteM replace-item c listAutiliteM item c listAutiliteM
  set listAutiliteR replace-item c listAutiliteR calculerutiliteActifs c
  set tempL replace-item c tempL (item c tempL + item c listAutiliteR)
  set c c + 1
]
]

ask patches [
set c 0
while [c < Ncsp] [
  ;set listAutiliteM replace-item c listAutiliteM item c listAutiliteM
  set listAutiliteR replace-item c listAutiliteR (item c listAutiliteR / item c tempL )
  set c c + 1
]
]

end





to updateUtiliteEmplois
let tempL []
let c 0
while  [c < Ncsp] [
  set tempL lput 0 tempL
  set c c + 1
]
ask patches [
set c 0
while [c < Ncsp] [
  set listEutiliteM replace-item c listEutiliteM item c listEutiliteM
  set listEutiliteR replace-item c listEutiliteR calculerUtiliteEmplois c
  set tempL replace-item c tempL (item c tempL + item c listEutiliteR)
  set c c + 1
]
]

ask patches [
set c 0
while [c < Ncsp] [
  ;set listEutiliteM replace-item c listEutiliteM item c listEutiliteM
  set listEutiliteR replace-item c listEutiliteR (item c listEutiliteR / item c tempL )
  set c c + 1
]
]

end




